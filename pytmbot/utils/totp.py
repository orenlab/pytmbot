#!/usr/local/bin/python3
"""
(c) Copyright 2025, Denis Rozhnovskiy <pytelemonbot@mail.ru>
pyTMBot - A simple Telegram bot to handle Docker containers and images,
also providing basic information about the status of local servers.
"""

from __future__ import annotations

import base64
import hashlib
import io
import re
from typing import Final

import pyotp
import qrcode

from pytmbot.exceptions import QRCodeError, ErrorContext, TOTPError
from pytmbot.globals import settings
from pytmbot.logs import BaseComponent


class TwoFactorAuthenticator(BaseComponent):
    """Two-factor authentication handler using TOTP (Time-based One-Time Password)."""

    # Constants
    TOTP_CODE_LENGTH: Final[int] = 6
    TOTP_DIGITS: Final[int] = 6
    TOTP_INTERVAL: Final[int] = 30
    HASH_DIGEST_SIZE: Final[int] = 64
    ISSUER_NAME: Final[str] = "pyTMbot TOTP"
    QR_CODE_FORMAT: Final[str] = "PNG"

    # Regex pattern for validating TOTP codes (6 digits)
    TOTP_CODE_PATTERN: Final[re.Pattern[str]] = re.compile(r"^\d{6}$")

    __slots__ = ("user_id", "username", "_salt", "_secret_cache")

    def __init__(self, user_id: int, username: str) -> None:
        """Initialize the TwoFactorAuthenticator with user ID and username.

        Args:
            user_id: The unique identifier for the user
            username: The username of the user

        Raises:
            TOTPError: If user_id or username is invalid
        """
        super().__init__("TwoFactorAuth")

        if not isinstance(user_id, int) or user_id <= 0:
            raise TOTPError(f"Invalid user_id: {user_id}. Must be a positive integer.")

        if not isinstance(username, str) or not username.strip():
            raise TOTPError(
                f"Invalid username: {username}. Must be a non-empty string."
            )

        self.user_id: int = user_id
        self.username: str = username.strip()
        self._salt: str = settings.access_control.auth_salt[0].get_secret_value()
        self._secret_cache: str | None = None  # Cache for secret to avoid regeneration

    def _generate_secret(self) -> str:
        """Generate a secret key for TOTP authentication.

        The secret key is generated by hashing the concatenation of the user ID,
        salt, and username using blake2b for enhanced security.

        Returns:
            str: The base32 encoded secret key

        Raises:
            TOTPError: If secret generation fails
        """
        if self._secret_cache is not None:
            return self._secret_cache

        try:
            # Concatenate the user ID, salt, and username
            message = f"{self.user_id}{self._salt}{self.username}".encode("utf-8")

            # Hash the concatenated message using blake2b
            hash_obj = hashlib.blake2b(message, digest_size=self.HASH_DIGEST_SIZE)

            # Encode the hash digest as base32 and decode it to a string
            self._secret_cache = base64.b32encode(hash_obj.digest()).decode("ascii")

            with self.log_context(user_id=self.user_id, username=self.username) as log:
                log.debug("TOTP secret generated and cached")

            return self._secret_cache

        except Exception as e:
            with self.log_context(user_id=self.user_id, username=self.username) as log:
                log.error(f"Secret generation failed: {e}")
            raise TOTPError(
                f"Failed to generate secret for user {self.username}: {e}"
            ) from e

    def _generate_totp_auth_uri(self) -> str:
        """Generate a TOTP authentication URI using the secret key and account information.

        Returns:
            str: The generated TOTP authentication URI

        Raises:
            TOTPError: If URI generation fails
        """
        try:
            # Generate TOTP object using the secret key
            totp = pyotp.TOTP(
                self._generate_secret(),
                digits=self.TOTP_DIGITS,
                interval=self.TOTP_INTERVAL,
            )

            # Generate the URI using the TOTP object and account name
            uri = totp.provisioning_uri(
                name=self.username, issuer_name=self.ISSUER_NAME
            )

            with self.log_context(user_id=self.user_id, username=self.username) as log:
                log.debug("TOTP URI generated")

            return uri

        except Exception as e:
            with self.log_context(user_id=self.user_id, username=self.username) as log:
                log.error(f"TOTP URI generation failed: {e}")
            raise TOTPError(
                f"Failed to generate TOTP URI for user {self.username}: {e}"
            ) from e

    def generate_totp_qr_code(self) -> bytes:
        """Generate a QR code for two-factor authentication.

        Returns:
            bytes: The generated QR code as bytes

        Raises:
            QRCodeError: If QR code generation fails
        """
        with self.log_context(
            user_id=self.user_id, username=self.username, operation="qr_generation"
        ) as log:
            log.debug("Starting QR code generation")

            try:
                # Generate the TOTP authentication URI
                auth_uri = self._generate_totp_auth_uri()

                # Create a QR code from the authentication URI (using simple approach like original)
                qr_code = qrcode.make(auth_uri)

                # Save the QR code as bytes in a BytesIO object
                with io.BytesIO() as img_bytes:
                    qr_code.save(img_bytes)
                    qr_data = img_bytes.getvalue()

                log.info(f"QR code generated", qr_size=len(qr_data))
                return qr_data

            except TOTPError:
                log.error("QR code generation failed due to TOTP error")
                raise QRCodeError(
                    ErrorContext(
                        message="QR code generation failed due to TOTP error.",
                        error_code="QR_CODE_TOTP_ERROR",
                        metadata={"username": self.username, "user_id": self.user_id},
                    )
                )
            except Exception as e:
                log.error(f"QR code generation failed: {e}")
                raise QRCodeError(
                    ErrorContext(
                        message="QR code generation failed.",
                        error_code="QR_CODE_GENERATION_ERROR",
                        metadata={
                            "username": self.username,
                            "user_id": self.user_id,
                            "original_error": str(e),
                        },
                    )
                ) from e

    def verify_totp_code(self, code: str) -> bool:
        """Verify the TOTP code for the user.

        Args:
            code: The TOTP code to be verified

        Returns:
            bool: True if the TOTP code is verified, False otherwise

        Raises:
            TOTPError: If verification process fails critically
        """
        with self.log_context(
            user_id=self.user_id, username=self.username, operation="totp_verification"
        ) as log:
            # Input validation
            if not isinstance(code, str):
                log.debug(f"Invalid code type: {type(code).__name__}")
                return False

            # Clean and validate code format
            cleaned_code = code.strip()
            if not self.TOTP_CODE_PATTERN.match(cleaned_code):
                log.debug(f"Invalid code format: length={len(cleaned_code)}")
                return False

            try:
                totp = pyotp.TOTP(
                    self._generate_secret(),
                    digits=self.TOTP_DIGITS,
                    interval=self.TOTP_INTERVAL,
                )

                log.debug("Starting TOTP verification")

                # Verify with some time window tolerance
                is_valid = totp.verify(cleaned_code, valid_window=1)

                if is_valid:
                    log.info("TOTP verification successful")
                    return True
                else:
                    log.warning(
                        "TOTP verification failed", code_length=len(cleaned_code)
                    )
                    return False

            except Exception as e:
                log.error(f"Critical TOTP verification error: {e}")
                raise TOTPError(
                    f"TOTP verification failed for user {self.username}: {e}"
                ) from e

    def get_backup_codes(self, count: int = 10) -> list[str]:
        """Generate backup codes for the user.

        Args:
            count: Number of backup codes to generate

        Returns:
            list[str]: List of backup codes

        Raises:
            TOTPError: If backup code generation fails
        """
        if not isinstance(count, int) or count <= 0 or count > 20:
            raise TOTPError(
                f"Invalid backup code count: {count}. Must be between 1 and 20."
            )

        with self.log_context(
            user_id=self.user_id,
            username=self.username,
            operation="backup_codes_generation",
            count=count,
        ) as log:
            try:
                # Use the secret as seed for deterministic backup codes
                secret = self._generate_secret()
                backup_codes = []

                for i in range(count):
                    # Generate deterministic backup code using secret + index
                    seed = f"{secret}{i}".encode("utf-8")
                    code_hash = hashlib.blake2b(seed, digest_size=4).digest()
                    code = base64.b32encode(code_hash).decode("ascii")[:8]  # 8 chars
                    backup_codes.append(f"{code[:4]}-{code[4:]}")  # Format: XXXX-XXXX

                log.info(f"Generated {count} backup codes")
                return backup_codes

            except Exception as e:
                log.error(f"Backup codes generation failed: {e}")
                raise TOTPError(
                    f"Failed to generate backup codes for user {self.username}: {e}"
                ) from e
